<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Snake â€” Dark Mode (Canvas)</title>
  <style>
    :root { --bg: #0b0f14; --panel: #0f141b; --muted: #7b8794; --text: #e6edf3; --accent: #4ade80; --accent-2: #60a5fa; --danger: #f87171; --grid: #15202b; --shadow: #00000055; }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body { margin: 0; overflow: hidden; background: radial-gradient(1200px 800px at 70% -200px, #10151d 0%, var(--bg) 60%) fixed; color: #e6edf3; font: 16px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Inter, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji"; display: grid; place-items: center; }
    .shell { width: 96vw; max-width: 100%; margin: 16px auto; }
    .card { background: linear-gradient(180deg, #0f141b 0%, #0c1117 100%); border: 1px solid #1f2937; border-radius: 18px; box-shadow: 0 10px 30px var(--shadow), inset 0 1px 0 #1a2230; padding: 14px; height: calc(100vh - 24px); display: flex; flex-direction: column; }
    header { display: flex; align-items: center; justify-content: space-between; gap: 12px; margin-bottom: 12px; flex: 0 0 auto; padding-left: calc(220px + 14px); }
    h1 { font-size: 18px; margin: 0; letter-spacing: 0.5px; color: #dbeafe; display: flex; align-items: center; gap: 10px; }
    h1 .dot { width: 10px; height: 10px; border-radius: 50%; background: var(--accent); box-shadow: 0 0 8px var(--accent); display: inline-block; }
    .stats { display: flex; gap: 12px; align-items: center; flex-wrap: wrap; }
    .chip { background: #0b1117; border: 1px solid #1f2937; padding: 6px 10px; border-radius: 999px; font-size: 13px; color: #7b8794; }
    .chip strong { color: #e6edf3; }
    .play { display: grid; grid-template-columns: 220px 1fr; gap: 14px; align-items: stretch; min-height: 0; }
    .legend { background: #0b1117; border: 1px solid #1f2937; border-radius: 14px; padding: 12px; color: #cbd5e1; display: flex; flex-direction: column; overflow: auto; max-height: 100%; }
    .legend-title { font-weight: 700; margin: 0 0 8px 0; font-size: 14px; letter-spacing: .3px; color: #dbeafe; }
    .legend-item { display: grid; grid-template-columns: 36px 1fr; grid-template-rows: auto auto; gap: 6px 10px; padding: 8px 6px; border-radius: 10px; align-items: center; }
    .legend-item canvas { width: 30px; height: 30px; border-radius: 8px; border: 1px solid #1f2937; background: #0c1219; }
    .legend-item .name { font-weight: 600; color: #e5e7eb; }
    .legend-item .desc { font-size: 12px; color: #94a3b8; grid-column: 1 / -1; }
    .controls { margin-top: 10px; padding-top: 10px; border-top: 1px dashed #1f2937; }
    .controls .desc { font-size: 12px; color: #94a3b8; }
    .control-row { display: grid; grid-template-columns: 1fr; gap: 4px; margin: 8px 0; }
    .kbdbar { display: inline-flex; gap: 4px; flex-wrap: wrap; }
    kbd { background: #0c1117; border: 1px solid #1f2937; border-radius: 6px; padding: 2px 6px; font-size: 12px; color: #cbd5e1; }
    .board-wrap { position: relative; flex: 1 1 auto; display: grid; place-items: center; min-height: 0; }
    canvas#board { display: block; background: radial-gradient(800px 600px at 50% 30%, #0f1621 0%, #0b1117 35%, #0a0f14 100%); border-radius: 14px; border: 1px solid #1f2937; }
    .overlay { position: absolute; inset: 0; display: grid; place-items: center; pointer-events: none; border-radius: 14px; }
    .overlay .panel { pointer-events: auto; background: rgba(8,11,15,0.82); backdrop-filter: blur(8px); border: 1px solid #1f2937; border-radius: 16px; padding: 18px 20px; text-align: center; max-width: 85%; box-shadow: 0 10px 30px var(--shadow); }
    .title { font-weight: 700; letter-spacing: 0.4px; margin-bottom: 6px; }
    .subtitle { color: #7b8794; font-size: 14px; margin-bottom: 12px; }
    .btns { display: flex; gap: 8px; justify-content: center; flex-wrap: wrap; }
    button { all: unset; padding: 10px 14px; background: #0c1219; border: 1px solid #1f2937; border-radius: 10px; cursor: pointer; color: #e6edf3; font-weight: 600; box-shadow: 0 4px 16px var(--shadow), inset 0 1px 0 #172033; transition: transform .06s ease, box-shadow .2s ease, background .2s ease; }
    button:hover { transform: translateY(-1px); }
    button:active { transform: translateY(1px); }
    .primary { background: linear-gradient(180deg, #1a2a1f, #0d1a12); border-color: #1f3b2a; }
    .danger { background: linear-gradient(180deg, #2a1a1a, #1a0d0d); border-color: #3b1f1f; }
    @media (max-width: 780px) { .play { grid-template-columns: 1fr; } .shell { width: 94vw; } header { padding-left: 0; } }
  </style>
</head>
<body>
  <div class="shell">
    <div class="card">
      <header>
        <h1><span class="dot"></span> Snake</h1>
        <div class="stats">
          <div class="chip">Score: <strong id="score">0</strong></div>
          <div class="chip">High: <strong id="high">0</strong></div>
          <div class="chip">Speed: <strong id="speed">1.0x</strong></div>
          <div class="chip">Slow: <strong id="slow">0.0s</strong></div>
          <div class="chip">HP: <strong id="hp">0</strong></div>
        </div>
      </header>
      <div class="play">
        <aside class="legend">
          <div class="legend-title">Legend</div>
          <div class="legend-item">
            <canvas id="icon-apple" width="36" height="36"></canvas>
            <div class="name">Apple</div>
            <div class="desc">+1 score, grow by 1, slightly increases base speed.</div>
          </div>
          <div class="legend-item">
            <canvas id="icon-banana" width="36" height="36"></canvas>
            <div class="name">Banana</div>
            <div class="desc">Temporarily slows speed; duration scales with high score (capped).</div>
          </div>
          <div class="legend-item">
            <canvas id="icon-orange" width="36" height="36"></canvas>
            <div class="name">Orange</div>
            <div class="desc">+1 hitpoint up to a small maximum.</div>
          </div>
          <div class="legend-item">
            <canvas id="icon-pear" width="36" height="36"></canvas>
            <div class="name">Pear</div>
            <div class="desc">Spawns in pairs; eating one teleports you to the other.</div>
          </div>
          <div class="legend-item">
            <canvas id="icon-cherry" width="36" height="36"></canvas>
            <div class="name">Cherry</div>
            <div class="desc">Spawns on edges; when wrap is off: next move only, hit a wall to wrap once; otherwise just +1 score.</div>
          </div>
          <div class="legend-item">
            <canvas id="icon-mouse" width="36" height="36"></canvas>
            <div class="name">Mouse</div>
            <div class="desc">Moves in 8 directions, avoids the snake, eats fruits; +5 if eaten.</div>
          </div>
          <div class="controls">
            <div class="legend-title">Controls</div>
            <div class="control-row">
              <div class="kbdbar"><kbd>W</kbd><kbd>A</kbd><kbd>S</kbd><kbd>D</kbd></div>
              <div class="desc">Move the snake. You cannot reverse into yourself.</div>
            </div>
            <div class="control-row">
              <div class="kbdbar"><kbd>P</kbd></div>
              <div class="desc">Pause / resume.</div>
            </div>
            <div class="control-row">
              <div class="kbdbar"><kbd>R</kbd></div>
              <div class="desc">Restart from the current start state.</div>
            </div>
            <div class="control-row">
              <div class="kbdbar"><kbd>T</kbd></div>
              <div class="desc">Toggle wrap-around walls.</div>
            </div>
          </div>
        </aside>
        <div class="board-wrap">
          <canvas id="board" width="640" height="640" aria-label="Snake board" role="img"></canvas>
        </div>
      </div>
    </div>
  </div>
  <script>
  (() => {
    const canvas = document.getElementById('board');
    const ctx = canvas.getContext('2d');
    let boardSize = 0;
    let errorCaptured = false;
    function handleRuntimeError(err) {
      let m = '';
      try { m = (err && (err.message || err.stack || err+'') ) + ''; } catch(_) { m = String(err); }
      if (/ResizeObserver/i.test(m)) return;
      if (errorCaptured) return;
      errorCaptured = true;
      const msg = m || 'Error';
      showErrorOverlay(msg);
      try { console.error(err); } catch (_) {}
    }
    window.addEventListener('error', (e) => { handleRuntimeError(e && (e.error || e.message || e)); });
    window.addEventListener('unhandledrejection', (e) => { handleRuntimeError(e && (e.reason || e)); });
    let resizeRaf = 0;
    function scheduleFix() { if (resizeRaf) return; resizeRaf = requestAnimationFrame(() => { resizeRaf = 0; fixDPI(); }); }
    function fixDPI() {
      const dpr = window.devicePixelRatio || 1;
      const shell = document.querySelector('.shell');
      const card = document.querySelector('.card');
      const header = document.querySelector('header');
      const footer = document.querySelector('footer');
      const touch = document.querySelector('.touchpad');
      const cardStyles = getComputedStyle(card);
      const shellStyles = getComputedStyle(shell);
      const padTop = parseFloat(cardStyles.paddingTop)||0;
      const padBottom = parseFloat(cardStyles.paddingBottom)||0;
      const borderTop = parseFloat(cardStyles.borderTopWidth)||0;
      const borderBottom = parseFloat(cardStyles.borderBottomWidth)||0;
      const shellMT = parseFloat(shellStyles.marginTop)||0;
      const shellMB = parseFloat(shellStyles.marginBottom)||0;
      const headH = header ? header.offsetHeight||0 : 0;
      const footH = footer ? footer.offsetHeight||0 : 0;
      const touchH = touch && getComputedStyle(touch).display !== 'none' ? (touch.offsetHeight||0) : 0;
      const chrome = shellMT + shellMB + padTop + padBottom + borderTop + borderBottom + headH + footH + touchH;
      const availH = Math.max(0, Math.floor(window.innerHeight - chrome - 8));
      const availW = Math.floor(canvas.parentElement.clientWidth||0);
      const size = Math.max(140, Math.min(availW, availH));
      const dprW = Math.round(size * dpr);
      const dprH = Math.round(size * dpr);
      if (canvas.width === dprW && canvas.height === dprH && canvas.style.width === size + 'px' && canvas.style.height === size + 'px' && boardSize === size) { ctx.setTransform(dpr, 0, 0, dpr, 0, 0); return; }
      boardSize = size;
      canvas.style.width = size + 'px';
      canvas.style.height = size + 'px';
      if (canvas.width !== dprW) canvas.width = dprW;
      if (canvas.height !== dprH) canvas.height = dprH;
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
    if ('ResizeObserver' in window) { new ResizeObserver(() => { scheduleFix(); }).observe(canvas.parentElement); } else { window.addEventListener('resize', scheduleFix); }
    window.addEventListener('resize', scheduleFix);
    scheduleFix();

    const GRID = 24;
    const CELL = () => boardSize / GRID;
    const BASE_CPS = 6;
    const MAX_CPS = 16;
    const MIN_CPS = 3;
    const CPS_INC = 0.5;
    function baseCPS() { return Math.min(MAX_CPS, BASE_CPS + score * CPS_INC); }

    const MAX_HP = 3;
    const BANANA_SLOW = 2;
    const BANANA_BASE_MS = 3000;
    const BANANA_PER_HS_MS = 150;
    const BANANA_MAX_MS = 10000;

    const BASE_MOUSE_CPS = 4;
    const MIN_MOUSE_CPS = 2;
    const MAX_MOUSE_CPS = 14;

    let snake, dir, nextDir, score, playing, wrapWalls, lastTime, acc;
    let items, hp, slowUntil, slowAmount;
    let cherrySteps = 0;
    let mouse, mouseAcc = 0;

    const scoreEl = document.getElementById('score');
    const highEl = document.getElementById('high');
    const speedEl = document.getElementById('speed');
    const hpEl = document.getElementById('hp');
    const slowEl = document.getElementById('slow');

    const HS_KEY = 'snake_highscore_v1';
    const stored = +localStorage.getItem(HS_KEY) || 0;
    highEl.textContent = stored;

    function getCPS() {
      const now = performance.now();
      const slow = (slowUntil && now < slowUntil) ? slowAmount : 0;
      const base = baseCPS();
      const cps = Math.max(MIN_CPS, base - slow);
      const baseFactor = base / BASE_CPS;
      const effectFactor = Math.min(1, cps / base);
      speedEl.textContent = effectFactor < 1 ? `${baseFactor.toFixed(1)}x (Ã—${effectFactor.toFixed(2)})` : `${baseFactor.toFixed(1)}x`;
      const remain = Math.max(0, (slowUntil||0) - now);
      slowEl.textContent = `${(remain/1000).toFixed(1)}s`;
      return cps;
    }

    function getMouseCPS() {
      const now = performance.now();
      const boost = (mouse && mouse.boostUntil && now < mouse.boostUntil) ? mouse.boostAmount : 0;
      const cps = Math.max(MIN_MOUSE_CPS, Math.min(MAX_MOUSE_CPS, BASE_MOUSE_CPS + boost));
      return cps;
    }

    function rndCell() { return { x: Math.floor(Math.random()*GRID), y: Math.floor(Math.random()*GRID) }; }
    function key(x,y) { return `${x},${y}`; }
    function isSpecial(it) { return it.type==='banana' || it.type==='orange' || it.type==='pear' || it.type==='cherry'; }
    function specialPresent() { return items.some(isSpecial); }

    function occupiedSet() { const set = new Set(items.map(it=>key(it.x,it.y))); for (const s of snake) set.add(key(s.x,s.y)); return set; }
    function spawnAtEmpty() { const occ = occupiedSet(); let c, guard=0; do { c = rndCell(); guard++; } while (occ.has(key(c.x,c.y)) && guard < GRID*GRID); return c; }
    function spawnCherryAtEdge() { const occ = occupiedSet(); let guard=0; while (guard++ < GRID*GRID) { const side = Math.floor(Math.random()*4); let x=0,y=0; if (side===0) { x=0; y=Math.floor(Math.random()*GRID); } else if (side===1) { x=GRID-1; y=Math.floor(Math.random()*GRID); } else if (side===2) { y=0; x=Math.floor(Math.random()*GRID); } else { y=GRID-1; x=Math.floor(Math.random()*GRID); } if (!occ.has(key(x,y))) return {x,y}; } return spawnAtEmpty(); }

    function ensureApple() { if (!items.some(it=>it.type==='apple')) { const c = spawnAtEmpty(); items.push({type:'apple', x:c.x, y:c.y}); } }
    function maybeSpawnSpecial() {
      if (specialPresent()) return;
      const pick = Math.floor(Math.random()*4);
      if (pick === 0) { const c = spawnAtEmpty(); items.push({type:'banana', x:c.x, y:c.y}); return; }
      if (pick === 1) { const c = spawnAtEmpty(); items.push({type:'orange', x:c.x, y:c.y}); return; }
      if (pick === 2) { const a = spawnAtEmpty(); const b = spawnAtEmpty(); const pid = Math.random().toString(36).slice(2); items.push({type:'pear', pair:pid, x:a.x, y:a.y}); items.push({type:'pear', pair:pid, x:b.x, y:b.y}); return; }
      const e = spawnCherryAtEdge(); items.push({type:'cherry', x:e.x, y:e.y});
    }

    function spawnMouse() {
      const occ = occupiedSet(); let c, guard=0; do { c = rndCell(); guard++; } while (occ.has(key(c.x,c.y)) && guard < GRID*GRID);
      return { x:c.x, y:c.y, hp:0, boostUntil:0, boostAmount:0, cherryArmed:false };
    }

    function setInitialIdleState() {
      const cx = Math.floor(GRID/2);
      const cy = Math.floor(GRID/2);
      snake = [{x:cx+1,y:cy},{x:cx,y:cy},{x:cx-1,y:cy}];
      dir = {x:1,y:0};
      nextDir = {...dir};
      score = 0;
      hp = 0;
      slowUntil = 0;
      slowAmount = 0;
      cherrySteps = 0;
      playing = false;
      if (wrapWalls === undefined) wrapWalls = false;
      lastTime = 0;
      acc = 0;
      mouseAcc = 0;
      items = [];
      ensureApple();
      mouse = spawnMouse();
      scoreEl.textContent = score;
      hpEl.textContent = hp;
      getCPS();
    }

    function reset() { playing = true; lastTime = 0; acc = 0; mouseAcc = 0; removeOverlays(); getCPS(); hintOverlay('Pause with P Â· Toggle wrap with T'); }
    function newGame() { setInitialIdleState(); playing = true; lastTime = 0; acc = 0; mouseAcc = 0; removeOverlays(); getCPS(); hintOverlay('Pause with P Â· Toggle wrap with T'); }

    function addOverlay(html, id) { const wrap = document.querySelector('.board-wrap'); const overlay = document.createElement('div'); overlay.className = 'overlay'; overlay.id = id || ''; overlay.innerHTML = `<div class="panel">${html}</div>`; wrap.appendChild(overlay); return overlay; }
    function removeOverlays() { document.querySelectorAll('.overlay').forEach(n => n.remove()); }

    function startOverlay() { const html = `
        <div class="title">Snake â€” Dark Mode</div>
        <div class="subtitle">Use WASD. Eat apples. Bananas slow time briefly, oranges add HP, pears teleport, cherries add +1 and enable a one-step wrap only when wrap is off.</div>
        <div class="btns">
          <button class="primary" id="playBtn">Play</button>
          <button id="wrapBtn">Wrap: ${wrapWalls? 'On':'Off'}</button>
        </div>`; const o = addOverlay(html, 'start'); o.querySelector('#playBtn').addEventListener('click', reset); const wrapBtn = o.querySelector('#wrapBtn'); wrapBtn.addEventListener('click', () => { wrapWalls = !wrapWalls; wrapBtn.textContent = `Wrap: ${wrapWalls? 'On':'Off'}`; }); }

    function hintOverlay(text) { const html = `<div class="subtitle">${text}</div>`; const o = addOverlay(html, 'hint'); setTimeout(() => o.remove(), 2000); }
    function showErrorOverlay(message) { removeOverlays(); const safe = (message+"").replace(/[<>]/g, c => ({'<':'&lt;','>':'&gt;'}[c])); const html = `
        <div class="title" style="color: var(--danger)">Oops â€” something went wrong</div>
        <div class="subtitle" style="text-align:left;max-width:520px;white-space:pre-wrap">${safe}</div>
        <div class="btns"><button class="primary" id="reloadBtn">Reload</button></div>`; const o = addOverlay(html, 'error'); o.querySelector('#reloadBtn').addEventListener('click', () => location.reload()); }

    function gameOver() { playing = false; const best = Math.max(score, +localStorage.getItem(HS_KEY) || 0); localStorage.setItem(HS_KEY, best); highEl.textContent = best; const html = `
        <div class="title" style="color: var(--danger)">Game Over</div>
        <div class="subtitle">Score: <strong>${score}</strong> Â· Best: <strong>${best}</strong> Â· HP: <strong>${hp}</strong></div>
        <div class="btns">
          <button class="primary" id="restartBtn">Restart (R)</button>
          <button id="wrapToggle">Wrap: ${wrapWalls?'On':'Off'}</button>
        </div>`; const o = addOverlay(html, 'over'); o.querySelector('#restartBtn').addEventListener('click', newGame); o.querySelector('#wrapToggle').addEventListener('click', () => { wrapWalls = !wrapWalls; o.querySelector('#wrapToggle').textContent = `Wrap: ${wrapWalls? 'On':'Off'}`; }); }

    const KEYS = { KeyW:{x:0,y:-1}, KeyS:{x:0,y:1}, KeyA:{x:-1,y:0}, KeyD:{x:1,y:0} };
    document.addEventListener('keydown', (e) => { if (KEYS[e.code]) { const nd = KEYS[e.code]; if (snake.length > 1 && nd.x === -dir.x && nd.y === -dir.y) return; nextDir = nd; e.preventDefault(); } else if (e.code === 'KeyP') { playing = !playing; if (playing) removeOverlays(); else hintOverlay('Paused â€” press P to resume'); } else if (e.code === 'KeyR') { newGame(); } else if (e.code === 'KeyT') { wrapWalls = !wrapWalls; hintOverlay(`Wrap: ${wrapWalls? 'On':'Off'}`); } });

    function bindBtn(id, vec) { const el = document.getElementById(id); if (!el) return; el.addEventListener('click', () => { if (snake.length > 1 && vec.x === -dir.x && vec.y === -dir.y) return; nextDir = vec; }); }
    bindBtn('btn-up', {x:0,y:-1}); bindBtn('btn-down', {x:0,y:1}); bindBtn('btn-left', {x:-1,y:0}); bindBtn('btn-right',{x:1,y:0});

    function loop(ts) {
      if (errorCaptured) return;
      if (!lastTime) lastTime = ts;
      const dt = (ts - lastTime) / 1000;
      lastTime = ts;
      acc += dt;
      mouseAcc += dt;
      for (;;) {
        const stepS = 1 / getCPS();
        if (acc < stepS) break;
        try { tick(); } catch (err) { handleRuntimeError(err); return; }
        acc -= stepS;
      }
      for (;;) {
        const stepM = 1 / getMouseCPS();
        if (mouseAcc < stepM) break;
        try { tickMouse(); } catch (err) { handleRuntimeError(err); return; }
        mouseAcc -= stepM;
      }
      getCPS();
      try { draw(); } catch (err) { handleRuntimeError(err); return; }
      if (!errorCaptured) requestAnimationFrame(loop);
    }

    function eatAt(nx, ny) {
      const idx = items.findIndex(it => it.x===nx && it.y===ny);
      if (idx === -1) return {type:null};
      const it = items[idx];
      if (it.type === 'apple') { items.splice(idx,1); score += 1; scoreEl.textContent = score; ensureApple(); maybeSpawnSpecial(); return {type:'apple'}; }
      if (it.type === 'banana') { items.splice(idx,1); const best = +localStorage.getItem(HS_KEY) || 0; const dur = Math.min(BANANA_MAX_MS, BANANA_BASE_MS + best * BANANA_PER_HS_MS); slowAmount = BANANA_SLOW; slowUntil = performance.now() + dur; getCPS(); return {type:'banana'}; }
      if (it.type === 'orange') { items.splice(idx,1); if (hp < MAX_HP) { hp += 1; hpEl.textContent = hp; } return {type:'orange'}; }
      if (it.type === 'pear') { const pid = it.pair; const other = items.find((j,i2)=> j.type==='pear' && j.pair===pid && i2!==idx); items = items.filter(j=>!(j.type==='pear' && j.pair===pid)); return {type:'pear', tx: other?other.x:nx, ty: other?other.y:ny}; }
      if (it.type === 'cherry') { items.splice(idx,1); score += 1; scoreEl.textContent = score; cherrySteps = wrapWalls ? 0 : 1; return {type:'cherry'}; }
      return {type:null};
    }

    function mouseEatAt(nx, ny) {
      const idx = items.findIndex(it => it.x===nx && it.y===ny);
      if (idx === -1) return {type:null};
      const it = items[idx];
      if (it.type === 'apple') { items.splice(idx,1); ensureApple(); maybeSpawnSpecial(); return {type:'apple'}; }
      if (it.type === 'banana') { items.splice(idx,1); const best = +localStorage.getItem(HS_KEY) || 0; const dur = Math.min(BANANA_MAX_MS, BANANA_BASE_MS + best * BANANA_PER_HS_MS); mouse.boostAmount = BANANA_SLOW; mouse.boostUntil = performance.now() + dur; return {type:'banana'}; }
      if (it.type === 'orange') { items.splice(idx,1); mouse.hp = (mouse.hp||0) + 1; return {type:'orange'}; }
      if (it.type === 'pear') { const pid = it.pair; const other = items.find((j,i2)=> j.type==='pear' && j.pair===pid && i2!==idx); items = items.filter(j=>!(j.type==='pear' && j.pair===pid)); return {type:'pear', tx: other?other.x:nx, ty: other?other.y:ny}; }
      if (it.type === 'cherry') { items.splice(idx,1); if (!wrapWalls) mouse.cherryArmed = true; return {type:'cherry'}; }
      return {type:null};
    }

    function safeForMouse(x,y) {
      if (!wrapWalls && (x<0||y<0||x>=GRID||y>=GRID)) return false;
      const k = key((x+GRID)%GRID, (y+GRID)%GRID);
      for (let i=0;i<snake.length;i++) { if (key(snake[i].x,snake[i].y)===k) return false; }
      return true;
    }

    function pickMouseMove() {
      const dirs = [
        {x:-1,y:-1},{x:0,y:-1},{x:1,y:-1},
        {x:-1,y:0},{x:1,y:0},
        {x:-1,y:1},{x:0,y:1},{x:1,y:1}
      ];
      if (!wrapWalls && mouse.cherryArmed) {
        const out = dirs.filter(d=>{ const nx=mouse.x+d.x, ny=mouse.y+d.y; return nx<0||ny<0||nx>=GRID||ny>=GRID; });
        if (out.length) {
          const card = out.filter(d => d.x === 0 || d.y === 0);
          let cand = card.length ? card : out;
          const prefer = cand.filter(d => (mouse.x===0 || mouse.x===GRID-1) ? d.y===0 : d.x===0);
          if (prefer.length) cand = prefer;
          return cand[Math.floor(Math.random()*cand.length)];
        }
        let best=null, bestd=1e9;
        for (const d of dirs) {
          const nx=mouse.x+d.x, ny=mouse.y+d.y; if (!safeForMouse(nx,ny)) continue;
          const ndist = Math.min(nx, GRID-1-nx, ny, GRID-1-ny);
          if (ndist < bestd) { bestd = ndist; best = d; }
        }
        if (best) return best;
      }
      const cand = dirs.filter(d=>{
        let nx = mouse.x + d.x, ny = mouse.y + d.y;
        if (wrapWalls) { nx = (nx+GRID)%GRID; ny = (ny+GRID)%GRID; }
        return safeForMouse(nx,ny);
      });
      if (cand.length===0) return {x:0,y:0};
      return cand[Math.floor(Math.random()*cand.length)];
    }

    function tickMouse() {
      if (!playing) return;
      const mv = pickMouseMove();
      let nx = mouse.x + mv.x, ny = mouse.y + mv.y;
      let usedCherry = false;
      if (nx < 0 || ny < 0 || nx >= GRID || ny >= GRID) {
        if (wrapWalls || mouse.cherryArmed) {
          nx = (nx+GRID)%GRID; ny = (ny+GRID)%GRID; usedCherry = !wrapWalls && mouse.cherryArmed;
          if (!wrapWalls && usedCherry) { if (mv.x !== 0) ny = mouse.y; if (mv.y !== 0) nx = mouse.x; }
        } else { return; }
      }
      if (!safeForMouse(nx,ny)) return;
      const pre = mouseEatAt(nx, ny);
      if (pre.type === 'pear') { nx = pre.tx; ny = pre.ty; }
      mouse.x = nx; mouse.y = ny;
      if (usedCherry) mouse.cherryArmed = false;
    }

    function tick() {
      if (!playing) return;
      dir = nextDir;
      let nx = snake[0].x + dir.x;
      let ny = snake[0].y + dir.y;
      const hadCherry = cherrySteps > 0;
      if (nx < 0 || ny < 0 || nx >= GRID || ny >= GRID) {
        if (wrapWalls || (hadCherry && !wrapWalls)) {
          nx = (nx + GRID) % GRID;
          ny = (ny + GRID) % GRID;
        } else {
          gameOver();
          return;
        }
      }
      let ate = false;
      const pre = eatAt(nx, ny);
      if (pre.type === 'pear') { nx = pre.tx; ny = pre.ty; ate = true; }
      else if (pre.type) { ate = true; }
      let collIndex = snake.findIndex((s,i)=> i && s.x===nx && s.y===ny);
      if (collIndex >= 0) {
        if (hp > 0) { hp -= 1; hpEl.textContent = hp; snake = snake.slice(0, collIndex); }
        else { gameOver(); return; }
      }
      snake.unshift({x:nx,y:ny});
      if (mouse && mouse.x===nx && mouse.y===ny) {
        if ((mouse.hp||0) > 0) { mouse.hp -= 1; const m2 = spawnMouse(); mouse.x = m2.x; mouse.y = m2.y; mouse.cherryArmed = false; mouse.boostUntil = 0; }
        else { score += 5; scoreEl.textContent = score; mouse = spawnMouse(); }
      }
      if (pre.type === 'apple' || pre.type === 'banana' || pre.type === 'orange' || pre.type === 'cherry') { getCPS(); }
      if (!ate) {
        const post = eatAt(nx, ny);
        if (post.type === 'apple' || post.type === 'banana' || post.type === 'orange' || post.type === 'cherry') { getCPS(); }
        else { snake.pop(); }
      }
      if (hadCherry) { cherrySteps = 0; }
    }

    function drawGrid() { const c = CELL(); ctx.save(); ctx.strokeStyle = '#15202b'; ctx.lineWidth = 1; ctx.globalAlpha = 0.8; for (let i=1;i<GRID;i++) { const p = Math.floor(i*c)+0.5; ctx.beginPath(); ctx.moveTo(p,0); ctx.lineTo(p,boardSize); ctx.stroke(); ctx.beginPath(); ctx.moveTo(0,p); ctx.lineTo(boardSize,p); ctx.stroke(); } ctx.restore(); }
    function roundRect(x, y, w, h, r) { ctx.beginPath(); ctx.moveTo(x + r, y); ctx.arcTo(x + w, y, x + w, y + h, r); ctx.arcTo(x + w, y + h, x, y + h, r); ctx.arcTo(x, y + h, x, y, r); ctx.arcTo(x, y, x + w, y, r); ctx.closePath(); }
    function drawCell(x, y, color1, color2) { const c = CELL(); const px = x*c, py = y*c; const r = Math.max(4, Math.floor(c/5)); const grad = ctx.createLinearGradient(px, py, px, py + c); grad.addColorStop(0, color1); grad.addColorStop(1, color2); ctx.fillStyle = grad; roundRect(px+1, py+1, c-2, c-2, r); ctx.fill(); }
    function drawSnake() { if (!snake || snake.length === 0) return; for (let i = snake.length - 1; i >= 0; i--) { const s = snake[i]; const t = i / Math.max(1, snake.length - 1); const base = 90 + Math.floor(t * 30); drawCell(s.x, s.y, `hsl(145, 70%, ${base}%)`, `hsl(145, 55%, ${base-18}%)`); } const head = snake[0]; if (!head) return; const c = CELL(); ctx.save(); ctx.fillStyle = '#0b1117'; const cx = head.x*c + c/2, cy = head.y*c + c/2; const ex = dir.x !== 0 ? (dir.x * c*0.18) : c*0.12; const ey = dir.y !== 0 ? (dir.y * c*0.18) : c*0.12; ctx.beginPath(); ctx.arc(cx - ex, cy - ey, Math.max(2, c*0.07), 0, Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(cx + ex, cy + ey, Math.max(2, c*0.07), 0, Math.PI*2); ctx.fill(); ctx.restore(); }

    function drawMouse() { if (!mouse) return; const c = CELL(); const px = mouse.x*c, py = mouse.y*c; const r = Math.max(4, Math.floor(c/4)); ctx.save(); const grad = ctx.createRadialGradient(px + c*0.35, py + c*0.35, c*0.05, px + c*0.5, py + c*0.5, c*0.4); grad.addColorStop(0, '#e5e7eb'); grad.addColorStop(1, '#9ca3af'); ctx.fillStyle = grad; roundRect(px+2, py+2, c-4, c-4, r); ctx.fill(); ctx.fillStyle = '#111827'; ctx.beginPath(); ctx.arc(px + c*0.35, py + c*0.38, Math.max(1.5,c*0.06), 0, Math.PI*2); ctx.arc(px + c*0.65, py + c*0.38, Math.max(1.5,c*0.06), 0, Math.PI*2); ctx.fill(); ctx.strokeStyle = '#111827'; ctx.lineWidth = Math.max(1, c*0.05); ctx.lineCap = 'round'; const mx = px + c*0.5, my = py + c*0.52; ctx.beginPath(); ctx.moveTo(mx, my - c*0.06); ctx.lineTo(mx, my - c*0.01); ctx.stroke(); ctx.beginPath(); ctx.moveTo(mx, my - c*0.01); ctx.quadraticCurveTo(mx - c*0.05, my + c*0.05, mx - c*0.1, my + c*0.02); ctx.moveTo(mx, my - c*0.01); ctx.quadraticCurveTo(mx + c*0.05, my + c*0.05, mx + c*0.1, my + c*0.02); ctx.stroke(); ctx.restore(); }

    function drawApple(g, px, py, c) { const r = g.createRadialGradient(px + c*0.55, py + c*0.45, c*0.1, px + c*0.5, py + c*0.5, c*0.5); r.addColorStop(0, '#ffb4b4'); r.addColorStop(1, '#f87171'); g.fillStyle = r; g.beginPath(); g.moveTo(px + c*0.18 + c*0.18, py + c*0.18); g.arcTo(px + c*0.82, py + c*0.18, px + c*0.82, py + c*0.82, c*0.18); g.arcTo(px + c*0.82, py + c*0.82, px + c*0.18, py + c*0.82, c*0.18); g.arcTo(px + c*0.18, py + c*0.82, px + c*0.18, py + c*0.18, c*0.18); g.arcTo(px + c*0.18, py + c*0.18, px + c*0.82, py + c*0.18, c*0.18); g.closePath(); g.fill(); g.strokeStyle = '#34d399'; g.lineWidth = Math.max(1.5, c*0.05); g.beginPath(); g.moveTo(px + c*0.5, py + c*0.15); g.quadraticCurveTo(px + c*0.7, py + c*0.0, px + c*0.78, py + c*0.18); g.stroke(); }
    function drawBanana(g, px, py, c) { g.save(); g.translate(px + c*0.5, py + c*0.5); g.rotate(-0.3); g.fillStyle = '#fde047'; g.beginPath(); g.ellipse(0, 0, c*0.35, c*0.18, 0, 0, Math.PI*2); g.fill(); g.fillStyle = '#78350f'; g.beginPath(); g.arc(-c*0.3, 0, c*0.04, 0, Math.PI*2); g.fill(); g.beginPath(); g.arc(c*0.3, 0, c*0.04, 0, Math.PI*2); g.fill(); g.restore(); }
    function drawOrange(g, px, py, c) { const r = g.createRadialGradient(px + c*0.55, py + c*0.45, c*0.1, px + c*0.5, py + c*0.5, c*0.5); r.addColorStop(0, '#ffd7a3'); r.addColorStop(1, '#fb923c'); g.fillStyle = r; g.beginPath(); g.arc(px + c*0.5, py + c*0.5, c*0.32, 0, Math.PI*2); g.fill(); g.strokeStyle = '#f59e0b'; g.beginPath(); g.moveTo(px + c*0.5, py + c*0.18); g.lineTo(px + c*0.62, py + c*0.06); g.stroke(); }
    function drawPear(g, px, py, c) { g.save(); g.translate(px + c*0.5, py + c*0.55); g.fillStyle = '#86efac'; g.beginPath(); g.moveTo(0, -c*0.2); g.bezierCurveTo(c*0.3, -c*0.2, c*0.35, c*0.15, 0, c*0.3); g.bezierCurveTo(-c*0.35, c*0.15, -c*0.3, -c*0.2, 0, -c*0.2); g.fill(); g.strokeStyle = '#166534'; g.beginPath(); g.moveTo(0, -c*0.28); g.lineTo(0, -c*0.45); g.stroke(); g.restore(); }
    function drawCherry(g, px, py, c) { g.save(); g.translate(px + c*0.5, py + c*0.5); g.fillStyle = '#ef4444'; g.beginPath(); g.arc(-c*0.12, c*0.1, c*0.16, 0, Math.PI*2); g.arc(c*0.16, c*0.04, c*0.16, 0, Math.PI*2); g.fill(); g.strokeStyle = '#10b981'; g.lineWidth = Math.max(1.2, c*0.05); g.beginPath(); g.moveTo(-c*0.12, c*0.1); g.quadraticCurveTo(-c*0.1, -c*0.2, 0, -c*0.25); g.moveTo(c*0.16, c*0.04); g.quadraticCurveTo(c*0.2, -c*0.2, 0, -c*0.25); g.stroke(); g.restore(); }
    function drawMouseIcon(g, px, py, c) { const r = Math.max(3, Math.floor(c/4)); const grad = g.createRadialGradient(px + c*0.35, py + c*0.35, c*0.05, px + c*0.5, py + c*0.5, c*0.4); grad.addColorStop(0, '#e5e7eb'); grad.addColorStop(1, '#9ca3af'); g.fillStyle = grad; const rr = (g2,x,y,w,h,rad)=>{ g2.beginPath(); g2.moveTo(x + rad, y); g2.arcTo(x + w, y, x + w, y + h, rad); g2.arcTo(x + w, y + h, x, y + h, rad); g2.arcTo(x, y + h, x, y, rad); g2.arcTo(x, y, x + w, y, rad); g2.closePath(); }; rr(g, px+2, py+2, c-4, c-4, r); g.fill(); g.fillStyle = '#111827'; g.beginPath(); g.arc(px + c*0.35, py + c*0.38, Math.max(1.2,c*0.06), 0, Math.PI*2); g.arc(px + c*0.65, py + c*0.38, Math.max(1.2,c*0.06), 0, Math.PI*2); g.fill(); g.strokeStyle = '#111827'; g.lineWidth = Math.max(1, c*0.05); g.lineCap = 'round'; const mx = px + c*0.5, my = py + c*0.52; g.beginPath(); g.moveTo(mx, my - c*0.06); g.lineTo(mx, my - c*0.01); g.stroke(); g.beginPath(); g.moveTo(mx, my - c*0.01); g.quadraticCurveTo(mx - c*0.05, my + c*0.05, mx - c*0.1, my + c*0.02); g.moveTo(mx, my - c*0.01); g.quadraticCurveTo(mx + c*0.05, my + c*0.05, mx + c*0.1, my + c*0.02); g.stroke(); }

    function drawItems() { const c = CELL(); for (const it of items) { const px = it.x*c, py = it.y*c; if (it.type==='apple') drawApple(ctx,px,py,c); else if (it.type==='banana') drawBanana(ctx,px,py,c); else if (it.type==='orange') drawOrange(ctx,px,py,c); else if (it.type==='pear') drawPear(ctx,px,py,c); else if (it.type==='cherry') drawCherry(ctx,px,py,c); } }

    function draw() { ctx.clearRect(0, 0, boardSize, boardSize); drawGrid(); drawItems(); drawMouse(); drawSnake(); const vg = ctx.createRadialGradient(boardSize/2, boardSize*0.35, boardSize*0.2, boardSize/2, boardSize/2, boardSize*0.75); vg.addColorStop(0, 'rgba(0,0,0,0)'); vg.addColorStop(1, 'rgba(0,0,0,0.18)'); ctx.fillStyle = vg; ctx.fillRect(0,0,boardSize,boardSize); }

    function renderLegendIcons() { const make = (id, fn) => { const c = document.getElementById(id); if (!c) return; const g = c.getContext('2d'); const s = Math.min(c.width, c.height); g.clearRect(0,0,c.width,c.height); fn(g, (c.width - s)/2, (c.height - s)/2, s); }; make('icon-apple', drawApple); make('icon-banana', drawBanana); make('icon-orange', drawOrange); make('icon-pear', drawPear); make('icon-cherry', drawCherry); make('icon-mouse', drawMouseIcon); }

    function runSelfTests() { const assert = (c,m)=>{ if(!c) throw new Error(m); }; try { for (let i=0;i<50;i++) { const r = rndCell(); assert(r.x>=0 && r.x<GRID && r.y>=0 && r.y<GRID, 'rndCell'); }
        setInitialIdleState();
        assert(snake.length===3, 'idle snake len');
        const a0 = Math.abs(snake[0].x-snake[1].x)+Math.abs(snake[0].y-snake[1].y);
        const a1 = Math.abs(snake[1].x-snake[2].x)+Math.abs(snake[1].y-snake[2].y);
        assert(a0===1 && a1===1, 'idle contiguous');
        assert(mouse && mouse.x>=0 && mouse.x<GRID && mouse.y>=0 && mouse.y<GRID, 'mouse spawned');
        assert(getMouseCPS() < getCPS(), 'mouse slower');
        const snapSnake = JSON.stringify(snake);
        const snapItems = JSON.stringify(items);
        reset();
        assert(playing, 'playing');
        assert(JSON.stringify(snake)===snapSnake, 'reset keeps idle snake');
        assert(JSON.stringify(items)===snapItems, 'reset keeps idle items');
        assert(items.some(i=>i.type==='apple'), 'apple present');
        const cps0 = getCPS(); score = 2; const cps1 = getCPS(); assert(cps1>cps0, 'cps inc');
        items.push({type:'orange',x:0,y:0}); snake[0]={x:-1,y:0}; dir={x:1,y:0}; nextDir=dir; tick(); assert(hp===1,'orange hp');
        items.push({type:'banana',x:0,y:0}); snake[0]={x:-1,y:0}; tick(); assert(slowUntil>performance.now(),'banana slow');
        const now = performance.now(); slowAmount = BANANA_SLOW; slowUntil = now + 1200; getCPS(); const a = /Ã—([0-9]+\.[0-9]+)/.exec(document.getElementById('speed').textContent); assert(a && parseFloat(a[1])>0 && parseFloat(a[1])<1, 'speed shows effect factor'); slowUntil = now + 400; getCPS(); const b = document.getElementById('slow').textContent; assert(parseFloat(b) < 1.2 && parseFloat(b) >= 0, 'slow counter updates');
        items = items.filter(it=>it.type==='apple'); maybeSpawnSpecial(); const t1 = new Set(items.filter(isSpecial).map(it=>it.type)); const c1 = items.filter(isSpecial).length; assert(t1.size<=1, 'one special type'); if (t1.has('pear')) { assert(c1===2,'pear pair only'); } else if (t1.size===1) { assert(c1===1,'single special'); } const snapTypes = Array.from(t1.values()).join(','); maybeSpawnSpecial(); maybeSpawnSpecial(); const t2 = new Set(items.filter(isSpecial).map(it=>it.type)); assert(Array.from(t2.values()).join(',')===snapTypes, 'no new special while one exists');
        function isEdge(p){return p.x===0||p.y===0||p.x===GRID-1||p.y===GRID-1}
        const ec = spawnCherryAtEdge(); assert(isEdge(ec),'cherry edge spawn');
        setInitialIdleState(); reset(); items.push({type:'cherry',x:snake[0].x+1,y:snake[0].y}); dir={x:1,y:0}; nextDir=dir; const s0=score; tick(); assert(score===s0+1,'cherry adds score'); nextDir={x:0,y:-1}; tick(); assert(cherrySteps===0,'cherry expires if not used');
        snake=[{x:GRID-2,y:12},{x:GRID-3,y:12},{x:GRID-4,y:12}]; dir={x:1,y:0}; nextDir=dir; items=[{type:'apple',x:0,y:0}]; const target={x:GRID-1,y:12}; items.push({type:'cherry',x:target.x,y:target.y}); tick(); assert(cherrySteps===1,'cherry armed'); tick(); assert(snake[0].x===0 && snake[0].y===12 && cherrySteps===0 && playing,'one-step wrap works');
        wrapWalls = true; setInitialIdleState(); reset(); items.push({type:'cherry',x:snake[0].x+1,y:snake[0].y}); dir={x:1,y:0}; nextDir=dir; const s1=score; tick(); assert(score===s1+1 && cherrySteps===0,'cherry no effect when wrap on'); wrapWalls = false;
        items = items.filter(it=>it.type==='apple'); const mbx = mouse.x, mby = mouse.y; items.push({type:'banana',x:mbx,y:mby}); const r1 = mouseEatAt(mbx,mby); assert(r1.type==='banana','mouse banana'); const cpm0 = BASE_MOUSE_CPS; const cpm1 = getMouseCPS(); assert(cpm1>cpm0,'mouse boosted');
        items = items.filter(it=>it.type==='apple'); const mox = mouse.x, moy = mouse.y; items.push({type:'orange',x:mox,y:moy}); const r2 = mouseEatAt(mox,moy); assert(r2.type==='orange' && mouse.hp>0,'mouse orange hp');
        const oldHP = mouse.hp; const oldScore = score; snake=[{x:mouse.x-1,y:mouse.y},{x:mouse.x-2,y:mouse.y},{x:mouse.x-3,y:mouse.y}]; dir={x:1,y:0}; nextDir=dir; tick(); assert(score===oldScore && mouse.hp===oldHP-1,'snake hits protected mouse');
        const oldScore2 = score; mouse.hp = 0; snake=[{x:mouse.x-1,y:mouse.y},{x:mouse.x-2,y:mouse.y},{x:mouse.x-3,y:mouse.y}]; dir={x:1,y:0}; nextDir=dir; const prevPos = key(mouse.x,mouse.y); tick(); assert(score===oldScore2+5 && key(mouse.x,mouse.y)!==prevPos,'snake eats mouse');
        wrapWalls = false; mouse.cherryArmed = true; mouse.x = 0; mouse.y = 10; const mx0 = mouse.x; tickMouse(); assert(mouse.x===GRID-1 && mouse.y===10,'mouse wraps on cherry when wrap off');
        items = items.filter(it=>it.type==='apple'); const pid='p'+Math.random().toString(36).slice(2); items.push({type:'pear',pair:pid,x:5,y:5}); items.push({type:'pear',pair:pid,x:8,y:9}); const r3 = mouseEatAt(5,5); assert(r3.type==='pear' && (r3.tx===8 && r3.ty===9),'mouse pear teleport');
        ['icon-apple','icon-banana','icon-orange','icon-pear','icon-cherry','icon-mouse'].forEach(id=>{ const el = document.getElementById(id); assert(el && el.width>0 && el.height>0, 'legend icon'); });
        setInitialIdleState(); removeOverlays(); startOverlay(); } catch (err) { showErrorOverlay('Self-test failed: '+err.message+"\n\n"+err.stack); } }

    setInitialIdleState(); startOverlay(); renderLegendIcons(); requestAnimationFrame(loop); setTimeout(runSelfTests, 0);
  })();
  </script>
</body>
</html>
